require "#{File.dirname(__FILE__)}/../module"

module Texier::Modules    
  # This module provides headings.
  class Heading < Texier::Module
    # Content of the first heading.
    attr_reader :title

    # Generated table of contents.
    attr_reader :toc

    options(
      # Autogenerate id's of heading
      :generate_id => true,

      # Prefix of autogenerated id's
      :id_prefix => 'toc-',

      # Level of top-level heading (1..6)
      :top => 1,

      # For surrounded headings: more #### means higher level.
      :more_means_higher => true,

      # Balancing mode. TODO: explain this.
      :balancing => :dynamic,

      # Styles of underlined headings.
      :levels => {
        '#' => 0,
        '*' => 1,
        '=' => 2,
        '-' => 3
      }
    )

    block_element('surrounded') do
      # Surrounded headings
      marker = e(/ *(\#{2,}|={2,}) +/) do |line|
        # Calculate relative level of heading according to length of the marker.
        level = [line.strip.length, 7].min
        level = 7 - level if more_means_higher
        level
      end
      tail = e(/ *(\#{2,}|={2,})? *$/)

      content = one_or_more(inline_element).up_to(tail)

      (marker & content & tail).map do |level, content, _|
        create_element(level, content)
      end
    end
    
    block_element('underlined') do
      # Underlined headings
      underline = empty
      levels.each do |char, value|
        underline << e(/ *#{Regexp.quote(char)}{3,} */) {value}
      end

      content = one_or_more(inline_element)

      (content & "\n" & underline).map do |content, _, level|
        create_element(level, content)
      end
    end

    def before_parse(input)
      @title = nil
      @toc = []
      @used_ids = {}

      input
    end

    def after_parse(dom)
      if balancing == :dynamic
        # Find highest heading level, then second highest, and so on. Then
        # create mapping table, where the highest level will be mapped to level
        # 1, second highest to level 2, and so on. Then modify levels of
        # headings according to this table.

        mapping = {}
        used_levels = {}
        toc.each do |element|
          used_levels[element[:level]] = true
        end

        used_levels = used_levels.keys.sort
        used_levels.each_with_index do |level, index|
          mapping[level] = [index + top, 6].min
        end

        # Assign new levels.
        toc.each do |element|
          element.name = "h#{mapping[element[:level]]}"
        end        
      end

      # Remove "level" attributes.
      toc.each do |element|
        element[:level] = nil
      end
    end

    protected

    # Create Heading dom element
    def create_element(level, content)
      heading = Texier::Element.new(:"h#{level + 1}", content, :level => level)
      heading[:id] ||= auto_id(content)

      # TODO: Handle also the case when content is an array of Element's.
      @title ||= heading.content.to_s
      @toc << heading

      heading
    end

    # Autogenerate unique id for heading.
    def auto_id(content)
      return nil unless generate_id

      id = id_prefix + Texier::Utilities.webalize(content.to_s)
      id = Texier::Utilities.sequel(id) while @used_ids[id]

      @used_ids[id] = true
      id
    end
  end
end
